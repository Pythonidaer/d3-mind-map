import { COLORS } from '../../../theme/colors';

export const nodes = [
  {
    id: "root",
    label: "Patterns & Anti-Patterns\nin Testing",
    definition: "Common best practices (patterns) and bad practices (anti-patterns) in test design and implementation",
    shape: "roundRect",
    color: COLORS.root,
  },
  {
    id: "patterns",
    label: "Testing Patterns",
    definition: "Proven techniques that lead to effective tests",
    shape: "ellipse",
    color: COLORS.veryLightGreen,
  },
  {
    id: "aaa",
    label: "Arrange-Act-Assert",
    definition: "Structure test code into setup (arrange), execute (act), and verify (assert) phases for clarity",
    shape: "rect",
    color: COLORS.mintGreen,
  },
  {
    id: "gwt",
    label: "Given-When-Then",
    definition: "Behavior-driven phrasing of Arrange-Act-Assert: Given some context, When an action happens, Then expect outcome (improves readability)",
    shape: "rect",
    color: COLORS.mintGreen,
  },
  {
    id: "fixtures",
    label: "Fixture Reuse Patterns",
    definition: "Use shared setup wisely (e.g., test setup methods, factory functions for test data) to reduce repetition but not obscure test intent",
    shape: "rect",
    color: COLORS.mintGreen,
  },
  {
    id: "param-tests",
    label: "Parameterized Tests",
    definition: "Write one test logic that runs with multiple inputs/expected outputs to cover many cases succinctly",
    shape: "rect",
    color: COLORS.mintGreen,
  },
  {
    id: "test-doubles",
    label: "Test Doubles Patterns",
    definition: "Use fakes/stubs/mocks appropriately: fake for simplifying integration (in-memory), stub for predetermined responses, mock for interaction verification",
    shape: "rect",
    color: COLORS.mintGreen,
  },
  {
    id: "fast-tests",
    label: "Fast Tests",
    definition: "Keep tests fast (especially unit) so they can be run often. This might mean using in-memory DB or disabling network calls by using stubs in tests.",
    shape: "rect",
    color: COLORS.mintGreen,
  },
  {
    id: "tests-as-docs",
    label: "Tests as Documentation",
    definition: "Write tests in a way that a reader can understand usage. E.g., name tests clearly (`it('calculates total with tax')`) and cover typical and edge cases to illustrate behavior.",
    shape: "rect",
    color: COLORS.mintGreen,
  },
  {
    id: "anti-patterns",
    label: "Testing\nAnti-Patterns",
    definition: "Common mistakes that make tests less effective or unreliable",
    shape: "ellipse",
    color: COLORS.lightRed,
  },
  {
    id: "flaky",
    label: "Flaky Tests",
    definition: "Tests that sometimes pass, sometimes fail due to timing, randomness, or environment. They erode trust. Example anti-pattern: relying on real timeouts or network in tests without control.",
    shape: "rect",
    color: COLORS.lighterRed,
  },
  {
    id: "interdependent",
    label: "Test Interdependence",
    definition: "Tests that depend on each other or shared state. E.g., one test populates DB and another assumes that data. This can break if order changes. Each test should be independent.",
    shape: "rect",
    color: COLORS.lighterRed,
  },
  {
    id: "ignore-failures",
    label: "Ignoring Failed Tests",
    definition: "Regularly seeing red tests and just ignoring or commenting them out. This defeats the purpose of the test suite. A failing test should be addressed immediately (either fix code or fix test).",
    shape: "rect",
    color: COLORS.lighterRed,
  },
  {
    id: "overspecified",
    label: "Overspecified Tests",
    definition: "Testing implementation details instead of behavior. For instance, asserting that a function calls another function X times (when the outcome is what matters). This makes tests brittle – they fail on harmless refactors.",
    shape: "rect",
    color: COLORS.lighterRed,
  },
  {
    id: "false-positive",
    label: "The Liar (False Positive)",
    definition: "A test that always passes but doesn't actually test anything meaningful (e.g., an empty test, or catching and ignoring exceptions). It gives a false sense of security. Every test should have clear assertions.",
    shape: "rect",
    color: COLORS.lighterRed,
  },
  {
    id: "ice-cream-cone",
    label: "Ice Cream Cone (Manual-heavy)",
    definition: "Relying mostly on manual or UI tests (slow), with few automated unit tests. This pattern results in slow feedback and often lower coverage of edge cases.",
    shape: "rect",
    color: COLORS.lighterRed,
  },
  {
    id: "wrong-thing",
    label: "Testing the Wrong Thing",
    definition: "Tests that assert behaviors that aren’t actually required or important, while missing critical requirements. Example: testing internal logging messages but not testing actual output of function.",
    shape: "rect",
    color: COLORS.lighterRed,
  }
];

export const links = [
  { source: "root", target: "patterns" },
  { source: "patterns", target: "aaa" },
  { source: "patterns", target: "gwt" },
  { source: "patterns", target: "fixtures" },
  { source: "patterns", target: "param-tests" },
  { source: "patterns", target: "test-doubles" },
  { source: "patterns", target: "fast-tests" },
  { source: "patterns", target: "tests-as-docs" },
  { source: "root", target: "anti-patterns" },
  { source: "anti-patterns", target: "flaky" },
  { source: "anti-patterns", target: "interdependent" },
  { source: "anti-patterns", target: "ignore-failures" },
  { source: "anti-patterns", target: "overspecified" },
  { source: "anti-patterns", target: "false-positive" },
  { source: "anti-patterns", target: "ice-cream-cone" },
  { source: "anti-patterns", target: "wrong-thing" }
];
